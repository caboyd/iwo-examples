{"version":3,"file":"SphereGeometry.js","sources":["../../../../iwo/src/geometry/SphereGeometry.ts"],"sourcesContent":["import { AttributeType, Geometry, Group } from \"./Geometry\";\r\n\r\nexport class SphereGeometry implements Geometry {\r\n    public indices: Uint16Array | Uint32Array | undefined;\r\n    public attribute_flags: number;\r\n    public attributes: Map<AttributeType, ArrayBufferView>;\r\n    public groups: Group[];\r\n\r\n    public isInterleaved: boolean;\r\n    public interleaved_attributes: Float32Array;\r\n\r\n    //Bounding Sphere\r\n\r\n    //Bounding Box (AABB)\r\n\r\n    public constructor(\r\n        radius: number,\r\n        horizontal_segments: number,\r\n        vertical_segments: number,\r\n        phi_start: number = 0,\r\n        phi_length: number = 2 * Math.PI,\r\n        theta_start = 0,\r\n        theta_length: number = Math.PI\r\n    ) {\r\n        this.attribute_flags = AttributeType.Vertex | AttributeType.Normals | AttributeType.Tex_Coords;\r\n        this.attributes = new Map<AttributeType, ArrayBufferView>();\r\n        this.groups = [];\r\n        this.isInterleaved = false;\r\n        this.interleaved_attributes = new Float32Array(1);\r\n\r\n        const flip_u = horizontal_segments < 0;\r\n        const flip_v = vertical_segments < 0;\r\n\r\n        let v_segments = Math.floor(Math.abs(vertical_segments));\r\n        if (v_segments < 2) v_segments = 2;\r\n        let h_segments = Math.floor(Math.abs(horizontal_segments));\r\n        if (h_segments < 3) h_segments = 3;\r\n\r\n        //180 theta should be full top to bottom\r\n        //if theta is 90 then should be only top half of circle\r\n        const theta_per_ring = (theta_length - theta_start) / v_segments;\r\n\r\n        //360 phi should be full ring around\r\n        const phi_per_quad = (phi_length - phi_start) / h_segments;\r\n\r\n        const verts = [];\r\n        const tex_coords = [];\r\n        const indices = [];\r\n        let index = 0;\r\n\r\n        const start_y = theta_start - Math.PI / 2;\r\n        for (let v = 0; v < v_segments; v++) {\r\n            //theta is y\r\n            const theta0 = start_y + theta_per_ring * v;\r\n            const cos_theta0 = Math.cos(theta0);\r\n\r\n            const theta1 = start_y + theta_per_ring * (v + 1);\r\n            const cos_theta1 = Math.cos(theta1);\r\n\r\n            const y0 = radius * Math.sin(theta0);\r\n            const y1 = radius * Math.sin(theta1);\r\n\r\n            //Draw a ring\r\n            for (let h = 0; h <= h_segments; h++) {\r\n                const phi = phi_start + phi_per_quad * h;\r\n                const sin_phi = Math.sin(phi);\r\n                const cos_phi = Math.cos(phi);\r\n\r\n                //cos_theta0 determines distance from center;\r\n                //top and bottom poles have x,z at 0.\r\n                const x0 = cos_phi * cos_theta0 * radius;\r\n                const z0 = sin_phi * cos_theta0 * radius;\r\n\r\n                const x1 = cos_phi * cos_theta1 * radius;\r\n                const z1 = sin_phi * cos_theta1 * radius;\r\n\r\n                //Get the top left vertex\r\n                verts.push(x0, y0, z0);\r\n\r\n                //get bottom left vertex\r\n                verts.push(x1, y1, z1);\r\n\r\n                let u = phi / (2 * Math.PI);\r\n                let v = theta0 / Math.PI + 0.5;\r\n                tex_coords.push(flip_u ? 1.0 - u : u, flip_v ? 1.0 - v : v);\r\n\r\n                u = phi / (2 * Math.PI);\r\n                v = theta1 / Math.PI + 0.5;\r\n                tex_coords.push(flip_u ? 1.0 - u : u, flip_v ? 1.0 - v : v);\r\n            }\r\n\r\n            for (let h = 0; h < h_segments; h++) {\r\n                const i = index;\r\n                indices.push(i, i + 1, i + 2, i + 2, i + 1, i + 3);\r\n                index += 2;\r\n            }\r\n            index += 2;\r\n        }\r\n\r\n        this.attributes.set(AttributeType.Vertex, new Float32Array(verts));\r\n        this.attributes.set(AttributeType.Normals, new Float32Array(verts));\r\n        this.attributes.set(AttributeType.Tex_Coords, new Float32Array(tex_coords));\r\n        if (verts.length >= 65536) {\r\n            this.indices = new Uint32Array(indices);\r\n        } else this.indices = new Uint16Array(indices);\r\n\r\n        this.groups.push({ count: indices.length, offset: 0, material_index: 0 } as Group);\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}