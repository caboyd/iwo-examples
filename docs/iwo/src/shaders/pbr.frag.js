var pbrFrag = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\n#define PI 3.14159265358979\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS            0.002025\n\nout vec4 frag_color;\n\nin vec3 view_pos;\nin vec3 world_pos;\nin vec2 tex_coord;\nin vec3 normal;\nin vec3 view_normal;\nin vec3 world_normal;\nin vec3 camera_pos;\n\nlayout (std140) uniform ubo_per_frame{\n// base alignment   // aligned offset\n    mat4 view;// 64               // 0\n    mat4 view_inverse;// 64               // 64\n    mat4 projection;// 64               // 128\n    mat4 view_projection;// 64               // 192\n\n};\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float ao;\n    vec3 emissive_factor;\n\n    sampler2D albedo_sampler;\n    samplerCube irradiance_sampler;\n    samplerCube env_sampler;\n    sampler2D normal_sampler;\n    sampler2D occlusion_sampler;\n    sampler2D metal_roughness_sampler;\n    sampler2D emissive_sampler;\n    sampler2D brdf_LUT_sampler;\n    bool active_textures[7];\n};\n\nstruct Light {\n    vec4 position;\n    vec3 color;\n};\n\nuniform int u_light_count;\nuniform Light u_lights[16];\nuniform Material u_material;\nuniform vec3 light_ambient;\nuniform float gamma;\n\nfloat saturate(float a){\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat DistributionGGX_Trowbridge_Reitz (vec3 N, vec3 H, float perceptual_roughness) {\n    float roughness = perceptual_roughness * perceptual_roughness;\n\n    float a2 = roughness * roughness;\n    float NdotH = saturate(dot(N, H));\n    float NdotH2 = NdotH*NdotH;\n\n    float denom = (NdotH2 *  (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return a2 / denom;\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(vec3 N, vec3 V, vec3 L, float perceptual_roughness) {\n    float NdotV = saturate(dot(N, V));\n    float NdotL = saturate(dot(N, L));\n    float a2 = perceptual_roughness * perceptual_roughness;\n    // dotNL and dotNV are explicitly swapped. This is not a mistake.\n    float gv = NdotL * sqrt(a2 + (1.0 - a2) * (NdotV*NdotV));\n    float gl = NdotV * sqrt(a2 + (1.0 - a2) * (NdotL*NdotL));\n    return 0.5 / max(gv + gl, 0.001);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0){\n    // Original approximation by Christophe Schlick '94\n    //float fresnel = pow(1.0 - cosTheta, 5.0);\n\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n    float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n    return (1.0 - F0) * fresnel + F0;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float perceptual_roughness)\n{\n    float roughness = perceptual_roughness * perceptual_roughness;\n\n    // See fresnelSchlick\n    float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n    vec3 Fr = max(vec3( 1.0 - roughness), F0) - F0;\n\n    return Fr * fresnel + F0;\n}\n\nbool isnan( float val )\n{\n    return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n    // important: some nVidias failed to cope with version below.\n    // Probably wrong optimization.\n    /*return ( val <= 0.0 || 0.0 <= val ) ? false : true;*/\n}\n\n//https://github.com/google/filament/blob/3862b44ef4a2cd3c41dec85a8d5760835ba15f0d/shaders/src/light_indirect.fs#L101\nfloat perceptualRoughnessToLod(float perceptualRoughness) {\n    // The mapping below is a quadratic fit for log2(perceptualRoughness)+iblRoughnessOneLevel when\n    // iblRoughnessOneLevel is 4. We found empirically that this mapping works very well for\n    // a 256 cubemap with 5 levels used. But also scales well for other iblRoughnessOneLevel values.\n    const float MAX_REFLECTION_LOD = 4.0;\n    return MAX_REFLECTION_LOD * perceptualRoughness * (2.0 - perceptualRoughness);\n}\n\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n    vec3 q0 = dFdx( eye_pos );\n    vec3 q1 = dFdy( eye_pos );\n    vec2 st0 = dFdx( tex_coord.st );\n    vec2 st1 = dFdy( tex_coord.st );\n    float scale = sign( st1.t * st0.s - st0.t * st1.s );\n    vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n    vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n    vec3 N = normalize( surf_norm );\n    mat3 tsn = mat3( S, T, N );\n    mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n    return normalize( tsn * mapN );\n}\n\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv, vec2 tangentSpaceParams) {\n    uv = gl_FrontFacing ? uv : -uv;\n    vec3 dp1 = dFdx(p);\n    vec3 dp2 = dFdy(p);\n    vec2 duv1 = dFdx(uv);\n    vec2 duv2 = dFdy(uv);\n    vec3 dp2perp = cross(dp2, normal);\n    vec3 dp1perp = cross(normal, dp1);\n    vec3 tangent = dp2perp*duv1.x+dp1perp*duv2.x;\n    vec3 bitangent = dp2perp*duv1.y+dp1perp*duv2.y;\n    tangent *= tangentSpaceParams.x;\n    bitangent *= tangentSpaceParams.y;\n    float invmax = inversesqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));\n    return mat3(tangent*invmax, bitangent*invmax, normal);\n}\n\nvec3 perturbNormalBase(mat3 cotangentFrame, vec3 normal, float scale) {\n    normal = normalize(normal*vec3(scale, scale, 1.0));\n    return normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame, vec3 textureSample, float scale) {\n    return perturbNormalBase(cotangentFrame, textureSample, scale);\n}\n\nvoid main() {\n    vec3 albedo;\n    if (u_material.active_textures[0])\n    albedo = texture(u_material.albedo_sampler, tex_coord).rgb;\n    else\n    albedo = u_material.albedo.rgb;\n\n    vec3 emission;\n    if(u_material.active_textures[6])\n        emission = u_material.emissive_factor *  texture(u_material.emissive_sampler,tex_coord).rgb;\n    else\n        emission = vec3(0);\n\n    float metallic = u_material.metallic;\n    if(u_material.active_textures[5])\n    metallic = u_material.metallic * texture(u_material.metal_roughness_sampler, tex_coord).b;\n\n    float perceptual_roughness = u_material.roughness;\n    if(u_material.active_textures[5])\n        perceptual_roughness = u_material.roughness * texture(u_material.metal_roughness_sampler, tex_coord).g;\n    perceptual_roughness = clamp(perceptual_roughness,MIN_PERCEPTUAL_ROUGHNESS, perceptual_roughness);\n\n    // Old Broken Normal Formula\n\n    // vec3 N = normalize(world_normal);\n    // if(u_material.active_textures[3]){\n    //    vec3 mapN = texture( u_material.normal_sampler, tex_coord ).xyz * 2.0 - vec3(1.0);\n    //     //mapN.y = -mapN.y;\n    //     //N = perturbNormal2Arb( view_pos, world_normal, mapN);\n    //     //vec3 mapN = texture( u_material.normal_sampler, tex_coord ).xyz;\n    //     //mapN.y = -mapN.y;\n    //     mat3 TBN = cotangent_frame(world_normal, view_pos, tex_coord, vec2(1.,1.));\n    //     N = perturbNormal(TBN, mapN, 1.0);\n    // }\n\n    //Normal\n    vec3 N = normalize(world_normal);\n\n    vec2 UV = tex_coord;\n    vec3 uv_dx = dFdx(vec3(UV, 0.0));\n    vec3 uv_dy = dFdy(vec3(UV, 0.0));\n    vec3 t_ = (uv_dy.t * dFdx(view_pos) - uv_dx.t * dFdy(view_pos)) /\n    (uv_dx.s * uv_dy.t - uv_dy.s * uv_dx.t);\n    vec3 n, t, b, ng; \n\n    ng = normalize(world_normal);\n    t = normalize(t_ - ng * dot(ng, t_));\n    b = cross(ng, t);\n\n    // For a back-facing surface, the tangential basis vectors are negated.\n    if (gl_FrontFacing == false) {\n        t *= -1.0;\n        b *= -1.0;\n        ng *= -1.0;\n    }\n\n    if(u_material.active_textures[3]){\n        vec3 mapN = texture( u_material.normal_sampler, tex_coord ).xyz * 2.0 - vec3(1.0);\n        mapN = normalize(mapN);\n        N = normalize(mat3(t,b,ng) * mapN);\n    } else {\n        N = ng;\n    }\n\n    //View Direction\n    vec3 V = normalize( camera_pos - world_pos);\n    //Reflect Direction\n    vec3 R = (reflect(-V, N));\n\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n\n    vec3 Lo = vec3(0.0);\n\n    vec3 color;\n\n    float AO = u_material.ao;\n    if(u_material.active_textures[4])\n        AO = u_material.ao * texture(u_material.occlusion_sampler, tex_coord).r;\n\n    for (int i = 0; i < u_light_count; i++){\n\n        // calculate per-light radiance\n\n        vec3 light_pos =  (u_lights[i].position).xyz;\n        vec3 L = light_pos;\n        vec3 radiance = u_lights[i].color;\n        //point light\n        if (u_lights[i].position.w == 1.0){\n            L = normalize(light_pos - world_pos);\n            float distance = length(light_pos - world_pos);\n            float attenuation = 1.0 / (distance * distance);\n            radiance  *= attenuation;\n        } else\n        L = normalize(L);\n\n        vec3 H = normalize(V + L);\n\n        float NDF = DistributionGGX_Trowbridge_Reitz(N, H, perceptual_roughness );\n        float G = G_GGX_SmithCorrelated(N, V, L, perceptual_roughness);\n        vec3 F = fresnelSchlick(saturate(dot(H, V)), F0);\n\n        vec3 specular = NDF * G * F;\n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n\n        kD *= (1.0 - metallic);\n\n        // add to outgoing radiance Lo\n        float NdotL = saturate(dot(N, L));\n        Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n\n    }\n\n    vec3 ambient;\n    float NoV = max(dot(N,V),0.0);\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(NoV, F0, perceptual_roughness);\n\n    vec3 irradiance;\n    if (u_material.active_textures[1]){\n        // ambient lighting (we now use IBL as the ambient term)\n        vec3 kS = F;\n        vec3 kD = 1.0 - kS;\n        if(!u_material.active_textures[2])\n            kD = vec3(1.0);\n        kD *= 1.0 - metallic;\n\n        irradiance = texture(u_material.irradiance_sampler, world_normal).rgb;\n        vec3 diffuse = (irradiance + (light_ambient)) * albedo;\n        ambient += (kD * diffuse) * AO ;\n\n    } else {\n        ambient = (light_ambient) * albedo * AO;\n    }\n\n    if (u_material.active_textures[2]){\n     \n        // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n        float lod = perceptualRoughnessToLod(perceptual_roughness);\n        vec3 prefilteredColor = textureLod(u_material.env_sampler, R, lod ).rgb;\n       \n        vec2 brdf  = texture(u_material.brdf_LUT_sampler, vec2(NoV, perceptual_roughness)).rg;\n        vec3  specular =  prefilteredColor * (F * brdf.x + brdf.y);\n     \n        ambient += (specular * AO);\n      \n    }\n    \n    color = Lo + emission + ambient;\n\n    \n    //HDR correction\n    color = color / (color + vec3(1.0));\n    //Gamma correction\n    color = pow(color, vec3(1.0/gamma));\n\n    //HDR + Gamma Correction Magic\n    //https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting  slide 140\n    //color = max(vec3(0.0), color - 0.004);\n    //color = (color * (6.2*color + 0.5)) / (color *(6.2*color + 1.7)+0.06);\n\n    frag_color = vec4(color,1.0);\n\n}\n\n"; // eslint-disable-line

export default pbrFrag;
//# sourceMappingURL=pbr.frag.js.map
