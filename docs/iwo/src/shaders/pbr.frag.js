var pbrFrag = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n\n#define PI 3.14159265358979\n\nout vec4 frag_color;\n\nin vec3 view_pos;\nin vec3 world_pos;\nin vec2 tex_coord;\nin vec3 view_normal;\nin vec3 world_normal;\nin vec3 camera_pos;\n\nlayout (std140) uniform ubo_per_frame{\n// base alignment   // aligned offset\n    mat4 view;// 64               // 0\n    mat4 view_inverse;// 64               // 64\n    mat4 projection;// 64               // 128\n    mat4 view_projection;// 64               // 192\n\n};\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n    float ao;\n\n    sampler2D albedo_sampler;\n    samplerCube irradiance_sampler;\n    samplerCube env_sampler;\n    sampler2D brdf_LUT_sampler;\n    bool active_textures[3];\n};\n\nstruct Light {\n    vec4 position;\n    vec3 color;\n};\n\nuniform int u_light_count;\nuniform Light u_lights[16];\nuniform Material u_material;\n\nfloat saturate(float a){\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat DistributionGGX_Trowbridge_Reitz (vec3 N, vec3 H, float roughness) {\n    float alphaRoughness = roughness * roughness;\n\n    float a2 = alphaRoughness * alphaRoughness;\n    float NdotH = saturate(dot(N, H));\n    float NdotH2 = NdotH*NdotH;\n\n    float denom = (NdotH2 *  (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return a2 / denom;\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = saturate(dot(N, V));\n    float NdotL = saturate(dot(N, L));\n    float a2 = roughness * roughness;\n    // dotNL and dotNV are explicitly swapped. This is not a mistake.\n    float gv = NdotL * sqrt(a2 + (1.0 - a2) * (NdotV*NdotV));\n    float gl = NdotV * sqrt(a2 + (1.0 - a2) * (NdotL*NdotL));\n    return 0.5 / max(gv + gl, 0.001);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0){\n    // Original approximation by Christophe Schlick '94\n    //return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n    float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n    return (1.0 - F0) * fresnel + F0;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    // Original approximation by Christophe Schlick '94\n    //return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n    float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n    return (1.0 - F0) * fresnel + F0;\n}\n\nvoid main() {\n    vec3 albedo;\n    if (u_material.active_textures[0])\n    albedo = texture(u_material.albedo_sampler, tex_coord).rgb;\n    else\n    albedo = u_material.albedo.rgb;\n\n    //Normal\n    vec3 N = normalize(world_normal);\n    //View Direction\n    vec3 V = normalize(camera_pos - world_pos);\n    //Reflect Direction\n    vec3 R = reflect(-V, N);\n\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, u_material.metallic);\n\n    vec3 Lo = vec3(0.0);\n\n    vec3 color;\n\n    for (int i = 0; i < u_light_count; i++){\n\n        // calculate per-light radiance\n\n        vec3 light_pos =  (u_lights[i].position).xyz;\n        vec3 L = light_pos;\n        vec3 radiance = u_lights[i].color;\n        //point light\n        if (u_lights[i].position.w == 1.0){\n            L = normalize(light_pos - world_pos);\n            float distance = length(light_pos - world_pos);\n            float attenuation = 1.0 / (distance * distance);\n            radiance  *= attenuation;\n        } else\n        L = normalize(L);\n\n        vec3 H = normalize(V + L);\n\n        float NDF = DistributionGGX_Trowbridge_Reitz(N, H, u_material.roughness);\n        float G = G_GGX_SmithCorrelated(N, V, L, u_material.roughness);\n        vec3 F = fresnelSchlick(saturate(dot(H, V)), F0);\n        vec3 specular = NDF * G * F;\n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n\n        kD *= (1.0 - u_material.metallic);\n\n        // add to outgoing radiance Lo\n        float NdotL = saturate(dot(N, L));\n        Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n\n    }\n\n    vec3 ambient;\n\n    // ambient lighting (we now use IBL as the ambient term)\n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, u_material.roughness);\n\n    vec3 irradiance;\n    if (u_material.active_textures[1]){\n        // ambient lighting (we now use IBL as the ambient term)\n        vec3 kS = F;\n        vec3 kD = 1.0 - kS;\n        if(!u_material.active_textures[2])\n            kD = vec3(1.0);\n        kD *= 1.0 - u_material.metallic;\n        \n        irradiance = texture(u_material.irradiance_sampler, N).rgb;\n        vec3 diffuse = irradiance * u_material.albedo;\n\n        ambient = (kD * diffuse) * u_material.ao;\n    } else {\n        ambient = vec3(0.03) * albedo * u_material.ao;\n    }\n\n    if (u_material.active_textures[2]){\n        // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n        const float MAX_REFLECTION_LOD = 4.0;\n        vec3 prefilteredColor = textureLod(u_material.env_sampler, R, u_material.roughness * MAX_REFLECTION_LOD).rgb;\n        vec2 brdf  = texture(u_material.brdf_LUT_sampler, vec2(max(dot(N, V), 0.0), u_material.roughness)).rg;\n        vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n\n        ambient = specular * u_material.ao;\n    }\n    \n    color = ambient + Lo ;\n\n    //    //HDR correction\n    //    color = color / (color + vec3(1.0));\n    //    //Gamme correction\n    //    color = pow(color, vec3(1.0/2.2));    \n\n    //HDR + Gamma Correction Magic\n    //https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting  slide 140\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2*color + 0.5)) / (color *(6.2*color + 1.7)+0.06);\n\n    frag_color = vec4(color, 1.0);\n\n}\n\n"; // eslint-disable-line

export default pbrFrag;
//# sourceMappingURL=pbr.frag.js.map
